library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_arith.all;
use ieee.std_logic_unsigned.all;

entity multiply_accumulater is

port(
	input0, input1, inpu2, input3, input4, input5, input6, input7: IN std_logic_vector(31 downto 0);
	clk, resetb: IN std_logic;
	sum: OUT std_logic_vector(31 downto 0);
	clock_taken: OUT std_logic_vector(7 downto 0);
	INITIAL_ST, MULT_ST,ADD_ST, DONE_ST: OUT std_logic;
	done: OUT std_logic
);

end multiply_accumulater;

architecture multiply_accumulater_RTL of multiply_accumulater is

	type state_type is (INITIAL_ST, MULT_ST,ADD_ST, DONE_ST);
	
	signal state : state_type;
	
	signal in0, in1, in2, in3, in4, in5, in6, in7 : std_logic_vector(31 downto 0);	--8 input elements
	signal mult0, mult1, mult2, mult3 : std_logic_vector(31 downto 0);	--4 intermedia multiplication results
	signal sum0, sum1, result : std_logic_vector(31 downto 0);	--2 intermedia add results & final result
	
	signal clocks_taken_int : std_logic_vector(7 downto 0);	--total clks needed
	
	
begin 
	
	sum <= result;
	clock_taken <= clocks_taken_int;
	
	INITIAL_ST <= '1' when (state = INITIAL_STATE) else '0'; 
	MULT_ST <= '1' when (state = CACHE_CHECK_STATE) else '0'; 
	ADD_ST <= '1' when (state = COMPUTE_STATE) else '0'; 
	DONE_ST <= '1' when (state = DONE_CALC_STATE) else '0'; 

	CU_DPU : process (clk, resetb)












end multiply_accumulater_RTL;
